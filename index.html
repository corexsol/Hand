<!doctype html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <!-- Viewport & insets fix -->
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
  <title>Hand Tap → Success (Video)</title>

  <!-- PWA hooks -->
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#030418">
  <meta name="theme-color" content="#030418" media="(prefers-color-scheme: dark)">
  <link rel="icon" href="icons/icon-192.png" sizes="192x192">
  <link rel="apple-touch-icon" href="icons/icon-192.png">

  <style>
    :root { --bg:#030418; --t:720ms; --e:cubic-bezier(.2,.8,.2,1); --vh:1vh; color-scheme: dark; }

    /* Hardening */
    *{ -webkit-user-select:none; user-select:none; -webkit-touch-callout:none; -webkit-tap-highlight-color:transparent; }
    html,body{ height:100%; margin:0; background:var(--bg); overflow:hidden; overscroll-behavior:none; font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif; }
    html,body,.stage,video,#hit,.success{ touch-action:none; }
    :fullscreen, ::backdrop{ background:#030418; }

    /* Use visual viewport height to kill bottom white bar */
    .stage, .success, #hit{ position:fixed; inset:0; height:calc(var(--vh) * 100) !important; }
    video{ width:100vw; height:calc(var(--vh) * 100) !important; }

    /* Scene 1: blurred cover bg + crisp contain fg */
    .stage{ background:var(--bg); }
    .stage video{ position:absolute; inset:0; }
    .stage .bg{
      object-fit:cover; transform:scale(1.15);
      filter:blur(12px) brightness(.7) saturate(1.08);
      transition:transform var(--t) var(--e), opacity var(--t) var(--e);
      z-index:0; pointer-events:none;
    }
    .stage .fg{
      object-fit:contain; background:transparent; transform:scale(1) translateZ(0);
      transition:transform 240ms var(--e), opacity var(--t) var(--e), filter var(--t) var(--e);
      z-index:1; will-change:transform,filter; pointer-events:none;
    }
    .pressed .stage .fg{ transform:scale(1.03); filter:brightness(.98); }
    .go .stage .fg{ transform:scale(1.06); filter:blur(2px) brightness(.9); transition:transform 520ms var(--e), filter 520ms var(--e); }
    .returning .stage .fg{ transform:scale(1); filter:none; }

    /* Fullscreen hitbox */
    #hit{ z-index:2; background:transparent; }

    /* Scene 2: overlay + SAME video as bg (blurred cover) + fg (crisp contain) */
    .success{
      z-index:4;
      background:rgba(3,4,24,0);
      backdrop-filter:blur(0px) saturate(110%); -webkit-backdrop-filter:blur(0px) saturate(110%);
      opacity:0; visibility:hidden; transform:scale(.985);
      transition:
        opacity var(--t) var(--e),
        transform var(--t) var(--e),
        visibility 0s linear var(--t),
        backdrop-filter 520ms var(--e),
        -webkit-backdrop-filter 520ms var(--e),
        background 520ms var(--e);
    }
    .go .success{
      opacity:1; visibility:visible; transform:scale(1);
      backdrop-filter:blur(12px) saturate(125%); -webkit-backdrop-filter:blur(12px) saturate(125%);
      background:rgba(3,4,24,.55);
    }

    .success video{ position:absolute; inset:0; pointer-events:none; }

    /* Second-scene background (same source), animated in */
    .success .sv-bg{
      object-fit:cover;
      transform:scale(1.08);
      filter:blur(16px) brightness(.72) saturate(1.1);
      opacity:0;
      transition: opacity 680ms var(--e), transform 900ms var(--e), filter 900ms var(--e);
      z-index:0;
    }
    .go .success .sv-bg{
      opacity:1;
      transform:scale(1.15);
      filter:blur(12px) brightness(.72) saturate(1.1);
    }
    .success.out .sv-bg{
      opacity:0; transform:scale(1.12); filter:blur(16px) brightness(.7) saturate(1.05);
      transition: opacity 420ms var(--e), transform 420ms var(--e), filter 420ms var(--e);
    }

    /* Second-scene foreground (same source), pronounced “IN” */
    .success .sv-fg{
      object-fit:contain;
      opacity:0; transform:translateY(22px) scale(.972); filter:blur(14px);
      z-index:1; will-change:opacity,transform,filter;
    }
    .go .success .sv-fg{ animation: svIn 820ms var(--e) 80ms both; }
    .success.out .sv-fg{ animation: svOut 420ms var(--e) forwards; }

    @keyframes svIn{
      0%   { opacity:0; transform:translateY(22px) scale(.972); filter:blur(14px); }
      60%  { opacity:1; transform:translateY(-3px) scale(1.012); filter:blur(0); }
      100% { opacity:1; transform:translateY(0)    scale(1.000); filter:blur(0); }
    }
    @keyframes svOut{
      0%   { opacity:1; transform:translateY(0) scale(1); filter:blur(0); }
      100% { opacity:0; transform:translateY(10px) scale(.985); filter:blur(10px); }
    }
  </style>
</head>
<body>
  <!-- Scene 1 -->
  <div class="stage">
    <video class="bg" id="bgVid" src="assets/hand-loop.mp4" preload="auto" autoplay muted loop playsinline></video>
    <video class="fg" id="fgVid" src="assets/hand-loop.mp4" preload="auto" autoplay muted loop playsinline></video>
  </div>

  <!-- Tap area -->
  <div id="hit" aria-hidden="true"></div>

  <!-- Scene 2 (same video as bg + fg) -->
  <section class="success" id="success">
    <!-- Remove loop if you want one-shot + freeze via handlers -->
    <video class="sv-bg" id="svBg" src="assets/hand-loop2.mp4" preload="auto" muted playsinline></video>
    <video class="sv-fg" id="svFg" src="assets/hand-loop2.mp4" preload="auto" muted playsinline></video>
  </section>

  <script>
  // Prevent context menu
  addEventListener('contextmenu', e => e.preventDefault(), {capture:true});

  // Visual viewport height fix (kills bottom white bar)
  (function(){
    function setVh(){
      const h = (window.visualViewport ? visualViewport.height : innerHeight);
      document.documentElement.style.setProperty('--vh', (h * 0.01) + 'px');
    }
    setVh();
    addEventListener('resize', setVh, {passive:true});
    addEventListener('orientationchange', () => setTimeout(setVh, 250), {passive:true});
    ['fullscreenchange','webkitfullscreenchange','msfullscreenchange']
      .forEach(ev => document.addEventListener(ev, () => setTimeout(setVh, 50), {passive:true}));
  })();

  const fg = document.getElementById('fgVid');
  const bg = document.getElementById('bgVid');
  const hit = document.getElementById('hit');
  const success = document.getElementById('success');
  const svBg = document.getElementById('svBg');
  const svFg = document.getElementById('svFg');

  // Autoplay nudge ONLY for scene-1 videos
  const nudge = () => { fg.play().catch(()=>{}); bg.play?.().catch(()=>{}); };
  addEventListener('touchstart', nudge, { once:true, passive:false });
  addEventListener('pointerdown', nudge, { once:true, passive:false });

  // Keep scene-1 fg/bg roughly in sync
  let rs1;
  function syncScene1(){
    if (Math.abs(fg.currentTime - bg.currentTime) > 0.15) bg.currentTime = fg.currentTime;
    if (fg.paused && !bg.paused) fg.play().catch(()=>{});
    if (!fg.paused && bg.paused) bg.play().catch(()=>{});
  }
  fg.addEventListener('timeupdate', () => { cancelAnimationFrame(rs1); rs1 = requestAnimationFrame(syncScene1); });
  fg.addEventListener('play', () => { bg.play().catch(()=>{}); syncScene1(); });

  // Scene-2 sync helpers
  let rs2;
  function syncScene2(){
    if (Math.abs(svFg.currentTime - svBg.currentTime) > 0.12) svBg.currentTime = svFg.currentTime;
  }
  svFg.addEventListener('timeupdate', () => { cancelAnimationFrame(rs2); rs2 = requestAnimationFrame(syncScene2); });

  function resetSuccessVideos(){
    [svFg, svBg].forEach(v => { try { v.pause(); } catch{}; });
    const set0 = v => { try { v.currentTime = 0; } catch{} };
    if (svFg.readyState >= 1) set0(svFg); else svFg.addEventListener('loadedmetadata', () => set0(svFg), {once:true});
    if (svBg.readyState >= 1) set0(svBg); else svBg.addEventListener('loadedmetadata', () => set0(svBg), {once:true});
  }
  function startSuccessVideos(){
    requestAnimationFrame(() => { svBg.play().catch(()=>{}); svFg.play().catch(()=>{}); });
  }
  function stopAndResetSuccessVideos(){
    [svFg, svBg].forEach(v => { try { v.pause(); } catch{}; try { v.currentTime = 0; } catch{}; });
  }

  // Tap-to-trigger-on-release
  const BACK_LOCK_MS = 4000;
  let useTouch = false, touches = 0, backUnlock = 0;

  function pressOn(){ if (!document.body.classList.contains('go')) document.body.classList.add('pressed'); }
  function pressOff(){ document.body.classList.remove('pressed'); }

  function fireSuccess(){
    resetSuccessVideos();
    document.body.classList.add('go');
    pressOff();
    backUnlock = performance.now() + BACK_LOCK_MS;
    startSuccessVideos();
  }

  // TOUCH path
  hit.addEventListener('touchstart', (e) => {
    useTouch = true;
    e.preventDefault();
    touches = e.touches.length;
    if (touches > 0) pressOn();
  }, {passive:false});
  function onTouchEnd(e){
    e.preventDefault();
    touches = e.touches.length;
    if (touches === 0){
      if (!document.body.classList.contains('go')) fireSuccess();
      else pressOff();
    }
  }
  hit.addEventListener('touchend', onTouchEnd, {passive:false});
  hit.addEventListener('touchcancel', onTouchEnd, {passive:false});

  // POINTER fallback
  const pset = new Set();
  hit.addEventListener('pointerdown', (e) => {
    if (useTouch) return;
    e.preventDefault();
    pset.add(e.pointerId);
    try { hit.setPointerCapture(e.pointerId); } catch(_){}
    pressOn();
  }, {passive:false});
  function onPointerUp(e){
    if (useTouch) return;
    pset.delete(e.pointerId);
    if (pset.size === 0){
      if (!document.body.classList.contains('go')) fireSuccess();
      else pressOff();
    }
  }
  hit.addEventListener('pointerup', onPointerUp, {passive:true});
  hit.addEventListener('pointercancel', onPointerUp, {passive:true});

  // Back via double-tap/click on success (after lock window)
  let lastTap = 0;
  function beginBack(){
    const t = performance.now();
    if (t < backUnlock) return;
    success.classList.add('out');
    stopAndResetSuccessVideos();
  }
  success.addEventListener('dblclick', beginBack);
  success.addEventListener('touchend', () => {
    const t = performance.now();
    if (t < backUnlock) return;
    if (t - lastTap < 320) beginBack();
    lastTap = t;
  }, {passive:true});

  // After overlay fade-out, return to scene 1
  success.addEventListener('transitionend', (e) => {
    if (e.propertyName === 'opacity' && success.classList.contains('out')) {
      success.classList.remove('out');
      document.body.classList.remove('go');
      document.body.classList.add('returning');
      setTimeout(() => document.body.classList.remove('returning'), 720);
    }
  });

  // Fullscreen + portrait lock once
  addEventListener('pointerdown', async () => {
    const el = document.documentElement;
    (el.requestFullscreen || el.webkitRequestFullscreen || el.msRequestFullscreen)?.call(el);
    try { await screen.orientation.lock('portrait'); } catch(_){}
  }, { once:true, passive:true });

  // Service worker
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('./sw.js').catch(console.error);
  }
  </script>
</body>
</html>
