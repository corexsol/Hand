<!doctype html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Hand Loop → Success</title>

  <!-- PWA hooks -->
  <link rel="manifest" href="manifest.webmanifest">
  <meta name="theme-color" content="#030418">
  <link rel="icon" href="icons/icon-192.png">
  <link rel="apple-touch-icon" href="icons/icon-192.png">

  <style>
    :root { --bg:#030418; --t:720ms; --e:cubic-bezier(.2,.8,.2,1); }

    /* Kiosk hardening */
    *{ -webkit-user-select:none; user-select:none; -webkit-touch-callout:none; -webkit-tap-highlight-color:transparent; }
    img,video{ -webkit-user-drag:none; user-drag:none; pointer-events:none; }
    html,body{ height:100%; margin:0; background:var(--bg); overflow:hidden; overscroll-behavior:none; font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif; }
    html,body,.stage,video{ touch-action:none; } /* kill gestures */

    /* Stage: two synced videos (bg blurred, fg crisp) */
    .stage{ position:fixed; inset:0; background:var(--bg); }
    .stage video{ position:absolute; inset:0; width:100vw; height:100vh; }
    .stage .bg{
      object-fit:cover;
      transform:scale(1.15) translate3d(0,0,0);
      filter:blur(12px) brightness(.7) saturate(1.08);
      will-change:transform,opacity;
      transition:transform var(--t) var(--e), opacity var(--t) var(--e);
      z-index:0;
    }
    .stage .fg{
      object-fit:contain;
      background:transparent; /* show blurred bg through letterboxing */
      transform:scale(1) translate3d(0,0,0);
      will-change:transform,opacity;
      transition:transform var(--t) var(--e), opacity var(--t) var(--e);
      z-index:1;
    }
    .holding .stage .fg{
      transform:scale(1.08) translate3d(0,0,0);
      transition:transform 1200ms linear, opacity var(--t) var(--e);
    }
    .go .stage .fg{ transform:scale(1.08) translate3d(0,0,0); transition:none; }
    .returning .stage .fg{ transform:scale(1) translate3d(0,0,0); transition:transform var(--t) var(--e), opacity var(--t) var(--e); }

    /* Indicator (we drive width via JS for pause/resume) */
    .hold-indicator{
      position:fixed; left:50%; top:5vh; transform:translateX(-50%) translate3d(0,0,0);
      width:min(42vw,360px); height:6px; border-radius:999px;
      background:rgba(255,255,255,.18); overflow:hidden; opacity:0;
      transition:opacity 150ms var(--e); pointer-events:none;
      box-shadow:0 2px 16px rgba(0,0,0,.25) inset, 0 0 24px rgba(120,150,255,.15);
      z-index:2;
    }
    .hold-indicator .bar{
      height:100%; width:0%;
      background:linear-gradient(90deg,#7aa2ff,#dfe7ff);
      box-shadow:0 0 18px rgba(120,150,255,.35);
    }
    .holding .hold-indicator{ opacity:.5; }

    /* Success (glass over same videos) */
    .success{
      position:fixed; inset:0; display:grid; place-items:center; text-align:center;
      color:#e8eefc; background:transparent; padding:2rem;
      opacity:0; visibility:hidden; transform:scale(.985) translate3d(0,0,0);
      transition:opacity var(--t) var(--e), transform var(--t) var(--e), visibility 0s linear var(--t);
      will-change:opacity,transform; z-index:3;
    }
    .success .glass{
      position:absolute; inset:0;
      background:rgba(3,4,24,.6);
      backdrop-filter:blur(8px) saturate(125%); -webkit-backdrop-filter:blur(8px) saturate(125%);
      transform:translate3d(0,0,0); pointer-events:none;
      transition:opacity var(--t) var(--e); opacity:1; will-change:opacity;
    }
    .success .glass::after{
      content:''; position:absolute; inset:0; background:rgba(3,4,24,.25);
      backdrop-filter:blur(16px) saturate(140%); -webkit-backdrop-filter:blur(16px) saturate(140%);
      transform:translate3d(0,0,0); opacity:0; transition:opacity 1.2s ease-out; will-change:opacity;
    }
    .success.intensify .glass::after{ opacity:1; }

    .success h1{
      position:relative; z-index:1; margin:0; letter-spacing:.02em; font-size:clamp(28px,5vw,80px);
      color:#eef3ff;
      text-shadow:0 0 6px rgba(120,150,255,.55),0 0 14px rgba(120,150,255,.45),0 0 34px rgba(120,150,255,.35),0 0 60px rgba(120,150,255,.25);
      opacity:0; transform:translateY(8px) scale(.985) translate3d(0,0,0);
      transition:opacity var(--t) var(--e), transform var(--t) var(--e);
      will-change:opacity,transform;
    }

    .go .success{ opacity:1; visibility:visible; transform:scale(1) translate3d(0,0,0); }
    .go .success h1{ animation:rise .7s var(--e) forwards, neon 2.6s .25s ease-in-out infinite alternate; }
    .success.out{ opacity:0; transition:opacity var(--t) var(--e); }
    .success.out h1{ animation:fall .55s var(--e) forwards; }
    .success.out .glass::after{ opacity:0; transition:opacity .4s ease-out; }

    @keyframes rise{ to{ opacity:1; transform:translateY(0) scale(1) translate3d(0,0,0); } }
    @keyframes fall{ to{ opacity:0; transform:translateY(8px) scale(.985) translate3d(0,0,0); } }
    @keyframes neon{
      0% { text-shadow:0 0 6px rgba(120,150,255,.55),0 0 14px rgba(120,150,255,.45),0 0 34px rgba(120,150,255,.35),0 0 60px rgba(120,150,255,.25); }
      100%{ text-shadow:0 0 10px rgba(170,200,255,.8),0 0 24px rgba(170,200,255,.65),0 0 52px rgba(170,200,255,.5),0 0 96px rgba(170,200,255,.4); }
    }

    @media (prefers-reduced-motion:reduce){
      .stage video,.success,.success h1,.hold-indicator{ transition:none; animation:none; }
    }
  </style>
</head>
<body>
  <!-- Videos -->
  <div class="stage">
    <video class="bg" id="bgVid" src="assets/hand-loop.mp4" preload="auto" autoplay muted loop playsinline></video>
    <video class="fg" id="fgVid" src="assets/hand-loop.mp4" preload="auto" autoplay muted loop playsinline></video>
  </div>

  <!-- Progress -->
  <div class="hold-indicator" aria-hidden="true"><div class="bar" id="bar"></div></div>

  <!-- Success -->
  <section class="success" id="success">
    <div class="glass" aria-hidden="true"></div>
    <h1 id="title">تم التدشين بحمد الله</h1>
  </section>

  <script>
  // Disable context menu
  addEventListener('contextmenu', e => e.preventDefault(), {capture:true});

  const fg = document.getElementById('fgVid');
  const bg = document.getElementById('bgVid');
  const success = document.getElementById('success');
  const title = document.getElementById('title');
  const bar = document.getElementById('bar');

  // Start playback on first interaction
  const nudgePlay = () => { fg.play().catch(()=>{}); bg.play?.().catch(()=>{}); };
  addEventListener('touchstart', nudgePlay, { once:true, passive:false });
  addEventListener('pointerdown', nudgePlay, { once:true, passive:false });

  // Keep videos in sync
  let rafSync;
  function syncV() {
    if (Math.abs(fg.currentTime - bg.currentTime) > 0.15) bg.currentTime = fg.currentTime;
    if (fg.paused && !bg.paused) fg.play().catch(()=>{});
    if (!fg.paused && bg.paused) bg.play().catch(()=>{});
  }
  fg.addEventListener('timeupdate', () => { cancelAnimationFrame(rafSync); rafSync = requestAnimationFrame(syncV); });
  fg.addEventListener('play', () => { bg.play().catch(()=>{}); syncV(); });
  fg.addEventListener('loadedmetadata', () => { try { bg.currentTime = fg.currentTime; } catch(_){} });

  // ---- Robust hold with accumulate/pause, centroid smoothing, join/leave grace ----
  const HOLD_MS = 1200;
  const BACK_LOCK_MS = 4000;
  const OUT_GRACE_MS = 220;    // must be out-of-bounds this long to cancel
  const LIFT_GAP_MS = 200;     // allow brief all-fingers-up gap
  const SMOOTH_ALPHA = 0.18;   // centroid smoothing factor/frame

  const SHORT = Math.min(innerWidth, innerHeight);
  const BASE_TOL = Math.max(120, Math.floor(SHORT * 0.20)); // forgiving base
  let moveTol = BASE_TOL;

  const down = new Map(); // id -> {x,y,w,h}
  let holding = false;
  let progress = 0;           // 0..1 accumulated
  let baseline = {x:0,y:0};
  let smooth = {x:0,y:0};
  let graceUntil = 0;
  let outDeadline = 0;
  let liftDeadline = 0;
  let tickId = 0;
  let lastTS = 0;
  let backUnlock = 0;

  function now(){ return performance.now(); }

  function centroid(){
    let sx=0, sy=0, n=0;
    down.forEach(p => { sx+=p.x; sy+=p.y; n++; });
    return n ? {x:sx/n, y:sy/n} : {x:0, y:0};
  }
  function bumpTolFromContacts(){
    let maxC = 0;
    down.forEach(p => { maxC = Math.max(maxC, p.w||0, p.h||0); });
    if (maxC) moveTol = Math.max(moveTol, Math.ceil(maxC * 1.5)); // more palm-safe
  }

  function startHoldIfNeeded(ts){
    if (holding || down.size === 0 || document.body.classList.contains('go')) return;
    holding = true;
    moveTol = BASE_TOL;
    bumpTolFromContacts();
    baseline = centroid();
    smooth = {...baseline};
    graceUntil = ts + 250; // start grace
    outDeadline = 0; liftDeadline = 0;
    document.body.classList.remove('returning');
    document.body.classList.add('holding');
    if (!tickId) { lastTS = ts; tickId = requestAnimationFrame(tick); }
  }

  function fireSuccess(){
    if (document.body.classList.contains('go')) return;
    document.body.classList.add('go');
    backUnlock = now() + BACK_LOCK_MS;
    document.body.classList.remove('holding');
    holding = false;
    progress = 1;
    bar.style.width = '100%';
  }

  function cancelHoldCore(){
    holding = false;
    progress = 0;
    bar.style.width = '0%';
    outDeadline = 0; liftDeadline = 0;
    document.body.classList.remove('holding');
  }

  function tick(ts){
    tickId = 0;
    if (document.body.classList.contains('go')) return; // stop ticking in success

    // Update centroid & smoothing
    const c = centroid();
    smooth.x += (c.x - smooth.x) * SMOOTH_ALPHA;
    smooth.y += (c.y - smooth.y) * SMOOTH_ALPHA;

    const dt = Math.max(0, ts - lastTS);
    lastTS = ts;

    const anyDown = down.size > 0;
    const inGrace = ts < graceUntil;

    // Compute in-bounds
    const dx = Math.abs(smooth.x - baseline.x);
    const dy = Math.abs(smooth.y - baseline.y);
    const inBounds = inGrace || (dx <= moveTol && dy <= moveTol);

    // Lift-gap handling
    if (!anyDown) {
      if (!liftDeadline) liftDeadline = ts + LIFT_GAP_MS;
    } else {
      liftDeadline = 0;
    }

    // Accumulate progress only if contact exists and in-bounds
    if (anyDown && inBounds) {
      progress += dt / HOLD_MS;
      if (progress >= 1) {
        fireSuccess();
      } else {
        bar.style.width = `${Math.floor(progress * 100)}%`;
      }
      outDeadline = 0; // reset out-of-bounds grace
    } else {
      // out-of-bounds or no fingers: apply grace windows
      if (liftDeadline && ts >= liftDeadline) {
        cancelHoldCore();
      } else {
        if (!outDeadline) outDeadline = ts + OUT_GRACE_MS;
        else if (ts >= outDeadline) cancelHoldCore();
      }
    }

    // Keep running while holding
    if (!document.body.classList.contains('go') && (holding || progress>0)) {
      tickId = requestAnimationFrame(tick);
    }
  }

  // Pointer handlers (non-passive to allow preventDefault)
  addEventListener('pointerdown', (e) => {
    e.preventDefault();
    down.set(e.pointerId, {x:e.clientX, y:e.clientY, w:e.width||0, h:e.height||0});
    bumpTolFromContacts();
    graceUntil = Math.max(graceUntil, now() + 200); // joining grace
    startHoldIfNeeded(now());
  }, { passive:false });

  addEventListener('pointermove', (e) => {
    e.preventDefault();
    if (down.has(e.pointerId)) {
      down.set(e.pointerId, {x:e.clientX, y:e.clientY, w:e.width||0, h:e.height||0});
    }
  }, { passive:false });

  function endPointer(id){
    down.delete(id);
    // Re-center baseline softly when composition changes
    if (holding && down.size>0) {
      const c = centroid();
      baseline.x = baseline.x*0.8 + c.x*0.2;
      baseline.y = baseline.y*0.8 + c.y*0.2;
      graceUntil = now() + 200; // grace after lift
    }
  }
  addEventListener('pointerup',   e => { e.preventDefault(); endPointer(e.pointerId); }, { passive:false });
  addEventListener('pointercancel', e => { e.preventDefault(); endPointer(e.pointerId); }, { passive:false });
  // no pointerleave to avoid false cancels

  // Success screen: 4s lockout, then double-tap to go back
  let lastTap=0;
  function beginBack(){
    const t = now();
    if (!document.body.classList.contains('go') || t < backUnlock) return;
    success.classList.remove('intensify');
    success.classList.add('out');
  }
  success.addEventListener('dblclick', beginBack);
  success.addEventListener('pointerup', () => {
    const t = now();
    if (t < backUnlock) return;
    if (t - lastTap < 320) beginBack();
    lastTap = t;
  }, { passive:true });

  title.addEventListener('animationstart', (e) => {
    if (e.animationName === 'rise') setTimeout(() => { success.classList.add('intensify'); }, 700);
  });
  title.addEventListener('animationend', (e) => {
    if (e.animationName === 'fall' && success.classList.contains('out')) {
      success.classList.remove('out');
      document.body.classList.remove('go');
      document.body.classList.add('returning');
      setTimeout(() => { document.body.classList.remove('returning'); }, 720);
      // reset hold state for next run
      progress = 0; bar.style.width = '0%';
    }
  });

  // SW + fullscreen
  if ('serviceWorker' in navigator) navigator.serviceWorker.register('./sw.js').catch(console.error);
  addEventListener('pointerdown', () => {
    const el = document.documentElement;
    (el.requestFullscreen || el.webkitRequestFullscreen || el.msRequestFullscreen)?.call(el);
  }, { once:true, passive:true });
  </script>
</body>
</html>
