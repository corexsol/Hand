<!doctype html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Hand Loop → Success</title>
  <meta name="theme-color" content="#030418" />
  <style>
    :root { --bg:#030418; --t:720ms; --e:cubic-bezier(.2,.8,.2,1); }

    *{ -webkit-user-select:none; user-select:none; -webkit-touch-callout:none; -webkit-tap-highlight-color:transparent; }
    html,body{ height:100%; margin:0; background:var(--bg); overflow:hidden; overscroll-behavior:none; font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif; }
    html,body,.stage,video,#hit{ touch-action:none; }

    .stage{ position:fixed; inset:0; background:var(--bg); }
    .stage video{ position:absolute; inset:0; width:100vw; height:100vh; }
    .stage .bg{
      object-fit:cover; transform:scale(1.15);
      filter:blur(12px) brightness(.7) saturate(1.08);
      transition:transform var(--t) var(--e), opacity var(--t) var(--e);
      z-index:0;
    }
    .stage .fg{
      object-fit:contain; background:transparent; transform:scale(1);
      transition:transform var(--t) var(--e), opacity var(--t) var(--e);
      z-index:1;
    }
    .holding .stage .fg{ transform:scale(1.08); transition:transform 1200ms linear; }
    .go .stage .fg{ transform:scale(1.08); transition:none; }
    .returning .stage .fg{ transform:scale(1); }

    #hit{ position:fixed; inset:0; z-index:2; background:transparent; }

    .hold-indicator{
      position:fixed; left:50%; top:5vh; transform:translateX(-50%);
      width:min(42vw,360px); height:6px; border-radius:999px;
      background:rgba(255,255,255,.18); overflow:hidden; opacity:0; z-index:3; pointer-events:none;
      transition:opacity 150ms var(--e); box-shadow:0 2px 16px rgba(0,0,0,.25) inset, 0 0 24px rgba(120,150,255,.15);
    }
    .hold-indicator .bar{ height:100%; width:0%; background:linear-gradient(90deg,#7aa2ff,#dfe7ff); box-shadow:0 0 18px rgba(120,150,255,.35); }
    .holding .hold-indicator{ opacity:.5; }

    .success{
      position:fixed; inset:0; display:grid; place-items:center; text-align:center;
      color:#e8eefc; background:rgba(3,4,24,.6);
      backdrop-filter:blur(8px) saturate(125%); -webkit-backdrop-filter:blur(8px) saturate(125%);
      padding:2rem; opacity:0; visibility:hidden; transform:scale(.985);
      transition:opacity var(--t) var(--e), transform var(--t) var(--e), visibility 0s linear var(--t);
      z-index:4;
    }
    .success h1{
      margin:0; letter-spacing:.02em; font-size:clamp(28px,5vw,80px); color:#eef3ff;
      text-shadow:0 0 6px rgba(120,150,255,.55),0 0 14px rgba(120,150,255,.45),0 0 34px rgba(120,150,255,.35),0 0 60px rgba(120,150,255,.25);
      opacity:0; transform:translateY(8px) scale(.985);
      transition:opacity var(--t) var(--e), transform var(--t) var(--e);
    }
    .go .success{ opacity:1; visibility:visible; transform:scale(1); }
    .go .success h1{ animation:rise .7s var(--e) forwards, neon 2.6s .25s ease-in-out infinite alternate; }
    .success.out{ opacity:0; }
    .success.out h1{ animation:fall .55s var(--e) forwards; }

    @keyframes rise{ to{ opacity:1; transform:translateY(0) scale(1); } }
    @keyframes fall{ to{ opacity:0; transform:translateY(8px) scale(.985); } }
    @keyframes neon{
      0%{ text-shadow:0 0 6px rgba(120,150,255,.55),0 0 14px rgba(120,150,255,.45),0 0 34px rgba(120,150,255,.35),0 0 60px rgba(120,150,255,.25); }
      100%{ text-shadow:0 0 10px rgba(170,200,255,.8),0 0 24px rgba(170,200,255,.65),0 0 52px rgba(170,200,255,.5),0 0 96px rgba(170,200,255,.4); }
    }
  </style>
</head>
<body>
  <div class="stage">
    <video class="bg" id="bgVid" src="assets/hand-loop.mp4" preload="auto" autoplay muted loop playsinline></video>
    <video class="fg" id="fgVid" src="assets/hand-loop.mp4" preload="auto" autoplay muted loop playsinline></video>
  </div>

  <div id="hit" aria-hidden="true"></div>

  <div class="hold-indicator" aria-hidden="true"><div class="bar" id="bar"></div></div>

  <section class="success" id="success">
    <h1 id="title">تم التدشين بحمد الله</h1>
  </section>

  <script>
  // Basic hardening
  addEventListener('contextmenu', e => e.preventDefault(), {capture:true});

  const fg = document.getElementById('fgVid');
  const bg = document.getElementById('bgVid');
  const hit = document.getElementById('hit');
  const success = document.getElementById('success');
  const title = document.getElementById('title');
  const bar = document.getElementById('bar');

  // Autoplay nudge
  const nudge = () => { fg.play().catch(()=>{}); bg.play?.().catch(()=>{}); };
  addEventListener('touchstart', nudge, { once:true, passive:false });
  addEventListener('pointerdown', nudge, { once:true, passive:false });

  // Minimal video sync
  let rs;
  function syncV(){
    if (Math.abs(fg.currentTime - bg.currentTime) > 0.15) bg.currentTime = fg.currentTime;
    if (fg.paused && !bg.paused) fg.play().catch(()=>{});
    if (!fg.paused && bg.paused) bg.play().catch(()=>{});
  }
  fg.addEventListener('timeupdate', () => { cancelAnimationFrame(rs); rs = requestAnimationFrame(syncV); });
  fg.addEventListener('play', () => { bg.play().catch(()=>{}); syncV(); });

  // Hold logic — touch-first, pointer fallback
  const HOLD_MS      = 1200;
  const ARM_MS       = 200;   // absorb full-palm burst
  const MICRO_UP_MS  = 80;    // tiny cancel guard for progress (visuals stop instantly)
  const BACK_LOCK_MS = 4000;

  let useTouch = false;       // prefer touch events on Android tablets
  let activeCount = 0;        // current contact count
  let pointers = new Set();   // fallback for pointer events
  let phase = 'idle';         // 'idle' | 'arming' | 'holding' | 'success'
  let progress = 0;           // 0..1
  let raf = 0, lastTS = 0, armUntil = 0, upCancelTimer = 0, backUnlock = 0;

  function now(){ return performance.now(); }
  function startTick(){ if (!raf) { lastTS = now(); raf = requestAnimationFrame(tick); } }
  function stopTick(){ if (raf){ cancelAnimationFrame(raf); raf = 0; } }

  function startArming(){ phase = 'arming'; armUntil = now() + ARM_MS; startTick(); }
  function startHolding(){ phase = 'holding'; document.body.classList.add('holding'); startTick(); }
  function resetHold(){
    phase = 'idle'; progress = 0; bar.style.width = '0%';
    document.body.classList.remove('holding'); clearTimeout(upCancelTimer); upCancelTimer = 0;
    stopTick();
  }
  function fireSuccess(){
    if (phase === 'success') return;
    phase = 'success';
    document.body.classList.add('go');
    document.body.classList.remove('holding');
    progress = 1; bar.style.width = '100%';
    backUnlock = now() + BACK_LOCK_MS;
    stopTick();
  }

  function tick(ts){
    raf = 0;
    if (phase === 'success') return;

    if (phase === 'arming'){
      if (ts >= armUntil){
        if (activeCount > 0) startHolding();
        else resetHold();
      }
    } else if (phase === 'holding'){
      const dt = Math.max(0, ts - lastTS); lastTS = ts;
      if (activeCount > 0){
        progress += dt / HOLD_MS;                 // ignore motion entirely
        if (progress >= 1) fireSuccess();
        else bar.style.width = Math.floor(progress*100) + '%';
      } else {
        // visuals already stopped in handlers; cancel progress after tiny guard via timer
        stopTick();
      }
    }

    if (phase === 'arming' || (phase === 'holding' && activeCount > 0)){
      raf = requestAnimationFrame(tick);
    }
  }

  // ---- TOUCH first ----
  hit.addEventListener('touchstart', (e) => {
    useTouch = true;
    e.preventDefault();
    activeCount = e.touches.length;
    if (phase === 'idle') startArming();
    // instant visuals on >0 touches only when holding starts
  }, { passive:false });

  function onTouchEnd(e){
    e.preventDefault();
    activeCount = e.touches.length;

    // Stop scaling instantly when all fingers lift
    if (phase === 'holding' && activeCount === 0){
      document.body.classList.remove('holding');
      if (!upCancelTimer){
        upCancelTimer = setTimeout(() => {
          upCancelTimer = 0;
          if (phase === 'holding' && activeCount === 0) resetHold();
        }, MICRO_UP_MS);
      }
    }
  }
  hit.addEventListener('touchend', onTouchEnd, { passive:false });
  hit.addEventListener('touchcancel', onTouchEnd, { passive:false });

  // ---- POINTER fallback (ignored once touch path is used) ----
  hit.addEventListener('pointerdown', (e) => {
    if (useTouch) return;
    e.preventDefault();
    pointers.add(e.pointerId);
    activeCount = pointers.size;
    try { hit.setPointerCapture(e.pointerId); } catch(_){}
    if (phase === 'idle') startArming();
  }, { passive:false });

  function onPointerUp(e){
    if (useTouch) return;
    pointers.delete(e.pointerId);
    activeCount = pointers.size;
    if (phase === 'holding' && activeCount === 0){
      document.body.classList.remove('holding');
      if (!upCancelTimer){
        upCancelTimer = setTimeout(() => {
          upCancelTimer = 0;
          if (phase === 'holding' && activeCount === 0) resetHold();
        }, MICRO_UP_MS);
      }
    }
  }
  hit.addEventListener('pointerup', onPointerUp, { passive:true });
  hit.addEventListener('pointercancel', onPointerUp, { passive:true });

  // Success: double-tap/click to go back (unlocked after 4s)
  let lastTap = 0;
  function beginBack(){
    const t = now();
    if (phase !== 'success' || t < backUnlock) return;
    success.classList.add('out');
  }
  success.addEventListener('dblclick', beginBack);
  success.addEventListener('pointerup', () => {
    const t = now();
    if (phase !== 'success' || t < backUnlock) return;
    if (t - lastTap < 320) beginBack();
    lastTap = t;
  }, { passive:true });

  title.addEventListener('animationend', (e) => {
    if (e.animationName === 'fall' && success.classList.contains('out')) {
      success.classList.remove('out');
      document.body.classList.remove('go');
      document.body.classList.add('returning');
      setTimeout(() => { document.body.classList.remove('returning'); }, 720);
      resetHold();
    }
  });

  // One-time fullscreen
  addEventListener('pointerdown', () => {
    const el = document.documentElement;
    (el.requestFullscreen || el.webkitRequestFullscreen || el.msRequestFullscreen)?.call(el);
  }, { once:true, passive:true });
  </script>
</body>
</html>
